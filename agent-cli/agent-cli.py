#!/usr/bin/env python3
import argparse
import os
import json
from pathlib import Path

AGENT_TEMPLATES = {
    "lead_scorer": {
        "description": "Scores and qualifies leads based on ICP fit",
        "default_tools": ["web_search", "crm_access"],
        "prompt_template": """You are a lead scoring agent for {business_name}.

TARGET CUSTOMER: {target_customer}

Evaluate leads and return:
- qualified: true/false
- score: 0-100
- reasoning: why this score
- next_action: what should happen next"""
    },
    "content_repurposer": {
        "description": "Repurposes long-form content into multiple formats",
        "default_tools": ["web_search"],
        "prompt_template": """You are a content repurposing agent for {business_name}.

Take input content and create:
- Twitter/X thread
- LinkedIn post
- Instagram caption
- Email newsletter snippet

Style: {brand_voice}"""
    },
    "social_media_manager": {
        "description": "Schedules and posts social media content across platforms",
        "default_tools": ["web_search", "notion_db", "slack_notification"],
        "prompt_template": """You are a social media management agent for {business_name}.

Brand voice: {brand_voice}
Target audience: {target_customer}

For the given topic or content:
1. Create platform-specific posts (Twitter, LinkedIn, Instagram)
2. Suggest optimal posting times
3. Generate relevant hashtags
4. Save to content calendar in Notion
5. Send preview to Slack for approval"""
    },
    "meeting_scheduler": {
        "description": "Finds meeting times and coordinates with attendees",
        "default_tools": ["calendar", "email_sender"],
        "prompt_template": """You are a meeting scheduling agent for {business_name}.

When given a meeting request:
1. Check calendar availability
2. Suggest 3 time slots
3. Send calendar invites
4. Send prep materials if needed
5. Add meeting notes doc"""
    },
    "cold_outreach": {
        "description": "Researches prospects and generates personalized outreach",
        "default_tools": ["web_search", "email_sender", "crm_access"],
        "prompt_template": """You are a cold outreach agent for {business_name}.

Target customer: {target_customer}
Value proposition: {{value_prop}}

For each prospect:
1. Research their company and role
2. Find relevant pain points
3. Craft personalized email
4. Log in CRM
5. Schedule follow-up"""
    },
    "content_researcher": {
        "description": "Researches topics and compiles insights",
        "default_tools": ["web_search", "notion_db"],
        "prompt_template": """You are a content research agent for {business_name}.

Research topic: {{topic}}

Deliver:
1. Key insights and data points
2. Trending angles
3. Competitor analysis
4. Content gaps
5. Save structured notes to Notion"""
    },
    "onboarding": {
        "description": "Automates client onboarding process",
        "default_tools": ["web_search", "email_sender", "calendar", "notion_db"],
        "prompt_template": """You are a client onboarding agent for {business_name}.

New client: {target_customer}

Tasks:
1. Research their business
2. Create Notion workspace
3. Schedule kickoff call
4. Send welcome email with next steps"""
    },
    "proposal_writer": {
        "description": "Generates custom proposals from discovery notes",
        "default_tools": ["web_search", "notion_db"],
        "prompt_template": """You are a proposal writing agent for {business_name}.

Client: {target_customer}
Discovery notes: {{discovery_notes}}

Generate proposal with:
- Problem statement
- Proposed solution
- Timeline
- Pricing
- Save to Notion"""
    },
    "monitor": {
        "description": "Monitors for events and takes action",
        "default_tools": ["web_search", "slack_notification"],
        "prompt_template": """You are a monitoring agent for {business_name}.

Monitor for: {{monitor_condition}}
When detected, take action: {{action}}
Notify via Slack"""
    },
    "meeting_notes": {
        "description": "Takes meeting notes and generates action items",
        "default_tools": ["notion_db", "email_sender", "slack_notification"],
        "prompt_template": """You are a meeting notes agent for {business_name}.

From meeting transcript/notes:
1. Summarize key discussion points
2. Extract action items with owners
3. List decisions made
4. Note follow-up questions
5. Save to Notion and notify team via Slack"""
    }
}

AGENT_CODE_TEMPLATE = '''"""
{agent_name} - {description}
Generated by Agent CLI
"""

from flask import Flask, request, jsonify
from anthropic import Anthropic
import os
import json

app = Flask(__name__)
client = Anthropic(api_key=os.environ.get('ANTHROPIC_API_KEY'))

CONFIG = {config_json}

@app.route('/health', methods=['GET'])
def health():
    return jsonify({{"status": "healthy", "agent": "{agent_name}"}})

@app.route('/run', methods=['POST'])
def run_agent():
    try:
        input_data = request.json
        print(f"Agent triggered with: {{json.dumps(input_data, indent=2)}}")

        result = execute_agent(input_data)
        return jsonify(result)

    except Exception as e:
        print(f"Error: {{str(e)}}")
        return jsonify({{"error": str(e)}}), 500

def execute_agent(input_data):
    """Main agent execution logic"""

    prompt = """{prompt}"""

    # Format prompt with input data
    formatted_prompt = prompt.format(**input_data)

    messages = [{{"role": "user", "content": formatted_prompt}}]

    # Define tools
    tools = {tools_json}

    # Initial API call
    response = client.messages.create(
        model="claude-sonnet-4-20250514",
        max_tokens=4096,
        tools=tools if tools else None,
        messages=messages
    )

    # Tool use loop
    while response.stop_reason == "tool_use":
        tool_use = next(block for block in response.content if block.type == "tool_use")

        print(f"Agent using tool: {{tool_use.name}}")

        # Mock tool results for now
        tool_result = {{"result": f"Mock result for {{tool_use.name}}"}}

        messages.append({{"role": "assistant", "content": response.content}})
        messages.append({{
            "role": "user",
            "content": [{{
                "type": "tool_result",
                "tool_use_id": tool_use.id,
                "content": json.dumps(tool_result)
            }}]
        }})

        response = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=4096,
            tools=tools if tools else None,
            messages=messages
        )

    # Extract final response
    final_text = next(
        (block.text for block in response.content if hasattr(block, "text")),
        None
    )

    # Try to parse JSON response
    try:
        import re
        json_match = re.search(r'\{{.*\}}', final_text, re.DOTALL)
        if json_match:
            result = json.loads(json_match.group())
        else:
            result = {{"output": final_text}}
    except:
        result = {{"output": final_text}}

    return result

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port)
'''

AGENT_SDK_TEMPLATE = '''"""
{agent_name} - {description}
Generated by Agent CLI - SDK Version
Uses Anthropic Agent SDK for automatic agentic loop
"""

from flask import Flask, request, jsonify
from anthropic import Anthropic
from anthropic.agents import Agent
import os
import json
import re

app = Flask(__name__)
client = Anthropic(api_key=os.environ.get('ANTHROPIC_API_KEY'))

CONFIG = {config_json}

# Define tool functions for SDK
{tool_functions}

@app.route('/health', methods=['GET'])
def health():
    return jsonify({{"status": "healthy", "agent": "{agent_name}", "sdk_version": True}})

@app.route('/run', methods=['POST'])
def run_agent():
    try:
        input_data = request.json
        print(f"Agent triggered with: {{json.dumps(input_data, indent=2)}}")

        result = execute_agent(input_data)
        return jsonify(result)

    except Exception as e:
        print(f"Error: {{str(e)}}")
        return jsonify({{"error": str(e)}}), 500

def execute_agent(input_data):
    """Main agent execution logic using SDK"""

    prompt = """{prompt}"""

    # Format prompt with input data
    try:
        formatted_prompt = prompt.format(**input_data)
    except KeyError as e:
        # If formatting fails, just use the raw input
        formatted_prompt = f"{{prompt}}\\n\\nInput: {{json.dumps(input_data)}}"

    # Create agent with SDK
    agent = Agent(
        client=client,
        model="claude-sonnet-4-20250514",
        system_prompt=formatted_prompt,
        tools={tool_list}
    )

    # Run agent - SDK handles the loop automatically
    result = agent.run("Process this request and provide structured output.")

    # Extract response text
    response_text = result.output if hasattr(result, 'output') else str(result)

    # Try to parse JSON response for Gumloop compatibility
    try:
        json_match = re.search(r'\{{.*\}}', response_text, re.DOTALL)
        if json_match:
            parsed_result = json.loads(json_match.group())
        else:
            parsed_result = {{"output": response_text}}
    except:
        parsed_result = {{"output": response_text}}

    return parsed_result

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    print(f"Starting SDK agent on port {{port}}...")
    app.run(host='0.0.0.0', port=port)
'''

TOOL_DEFINITIONS = {
    "web_search": {
        "name": "web_search",
        "description": "Search the web for information",
        "input_schema": {
            "type": "object",
            "properties": {
                "query": {"type": "string", "description": "Search query"}
            },
            "required": ["query"]
        }
    },
    "crm_access": {
        "name": "crm_access",
        "description": "Access CRM data",
        "input_schema": {
            "type": "object",
            "properties": {
                "action": {"type": "string", "description": "CRM action to perform"},
                "data": {"type": "object", "description": "Data for the action"}
            },
            "required": ["action"]
        }
    },
    "email_sender": {
        "name": "send_email",
        "description": "Send an email",
        "input_schema": {
            "type": "object",
            "properties": {
                "to": {"type": "string"},
                "subject": {"type": "string"},
                "body": {"type": "string"}
            },
            "required": ["to", "subject", "body"]
        }
    },
    "calendar": {
        "name": "schedule_meeting",
        "description": "Schedule a calendar meeting",
        "input_schema": {
            "type": "object",
            "properties": {
                "title": {"type": "string"},
                "datetime": {"type": "string"},
                "attendees": {"type": "array", "items": {"type": "string"}},
                "duration_minutes": {"type": "integer"}
            },
            "required": ["title", "datetime"]
        }
    },
    "notion_db": {
        "name": "notion_database",
        "description": "Create, read, update Notion database entries",
        "input_schema": {
            "type": "object",
            "properties": {
                "action": {"type": "string", "enum": ["create", "read", "update", "query"], "description": "Database action"},
                "database_id": {"type": "string", "description": "Notion database ID"},
                "properties": {"type": "object", "description": "Page properties"},
                "page_id": {"type": "string", "description": "Page ID for update operations"}
            },
            "required": ["action", "database_id"]
        }
    },
    "slack_notification": {
        "name": "send_slack_message",
        "description": "Send a message to Slack channel",
        "input_schema": {
            "type": "object",
            "properties": {
                "channel": {"type": "string", "description": "Slack channel name or ID"},
                "message": {"type": "string", "description": "Message text"},
                "blocks": {"type": "array", "description": "Rich message blocks"}
            },
            "required": ["channel", "message"]
        }
    },
    "database_query": {
        "name": "query_database",
        "description": "Query SQL database",
        "input_schema": {
            "type": "object",
            "properties": {
                "query": {"type": "string", "description": "SQL query"},
                "params": {"type": "array", "description": "Query parameters"}
            },
            "required": ["query"]
        }
    },
    "file_storage": {
        "name": "store_file",
        "description": "Store or retrieve files from cloud storage",
        "input_schema": {
            "type": "object",
            "properties": {
                "action": {"type": "string", "enum": ["upload", "download", "list"], "description": "File action"},
                "filename": {"type": "string", "description": "File name"},
                "content": {"type": "string", "description": "File content for upload"}
            },
            "required": ["action"]
        }
    }
}

def create_agent(args):
    """Generate agent from template"""

    # Validate agent type
    if args.type not in AGENT_TEMPLATES:
        print(f"‚ùå Unknown agent type: {args.type}")
        print(f"Available types: {', '.join(AGENT_TEMPLATES.keys())}")
        return

    template = AGENT_TEMPLATES[args.type]

    # Create agent directory
    agent_dir = Path("agents") / args.name.lower().replace(" ", "_")
    agent_dir.mkdir(parents=True, exist_ok=True)

    # Build config
    config = {
        "agent_name": args.name,
        "agent_type": args.type,
        "business_name": args.business or "Simple Flo Solutions",
        "target_customer": args.target or "small service businesses",
        "trigger_type": args.trigger or "webhook",
        "tools": args.tools.split(",") if args.tools else template["default_tools"],
        "brand_voice": args.voice or "clear, helpful, professional"
    }

    # Format prompt
    prompt = template["prompt_template"].format(**config)

    # Build tools list
    tools = [TOOL_DEFINITIONS[tool] for tool in config["tools"] if tool in TOOL_DEFINITIONS]

    # Generate agent code
    agent_code = AGENT_CODE_TEMPLATE.format(
        agent_name=config["agent_name"],
        description=template["description"],
        config_json=json.dumps(config, indent=2),
        prompt=prompt,
        tools_json=json.dumps(tools, indent=2) if tools else "[]"
    )

    # Write files
    (agent_dir / "agent.py").write_text(agent_code)
    (agent_dir / "config.json").write_text(json.dumps(config, indent=2))
    (agent_dir / "requirements.txt").write_text("flask==3.0.0\nanthropic==0.39.0\ngunicorn==21.2.0\n")
    (agent_dir / "Procfile").write_text("web: gunicorn agent:app")
    (agent_dir / "runtime.txt").write_text("python-3.11.0")

    # Create README
    readme = f"""# {config['agent_name']}

**Type:** {args.type}
**Description:** {template['description']}

## Configuration
- Business: {config['business_name']}
- Target Customer: {config['target_customer']}
- Trigger: {config['trigger_type']}
- Tools: {', '.join(config['tools'])}

## Deploy to Railway
1. Create new GitHub repo
2. Push this directory
3. Deploy to Railway
4. Add ANTHROPIC_API_KEY env variable

## Test Locally
```bash
export ANTHROPIC_API_KEY='your_key'
python agent.py
```

## Webhook URL
After deployment: `https://your-app.railway.app/run`

## Example Request
```bash
curl -X POST https://your-app.railway.app/run \\
  -H "Content-Type: application/json" \\
  -d '{{"input": "test"}}'
```
"""
    (agent_dir / "README.md").write_text(readme)

    print(f"\n‚úÖ Agent created: {agent_dir}")
    print(f"\nüìÅ Files generated:")
    print(f"   - agent.py")
    print(f"   - config.json")
    print(f"   - requirements.txt")
    print(f"   - Procfile")
    print(f"   - runtime.txt")
    print(f"   - README.md")
    print(f"\nüöÄ Next steps:")
    print(f"   1. cd {agent_dir}")
    print(f"   2. Review agent.py and customize if needed")
    print(f"   3. Test locally: python agent.py")
    print(f"   4. Deploy to Railway")

def generate_sdk_tool_functions(tools):
    """Generate Python tool functions for SDK"""
    tool_functions = []

    for tool in tools:
        tool_name = tool['name']
        tool_desc = tool['description']
        params = tool['input_schema']['properties']

        # Generate function signature
        param_list = ', '.join([f"{name}: str" for name in params.keys()])

        # Generate function
        func = f'''
def {tool_name}({param_list}):
    """
    {tool_desc}
    """
    # TODO: Implement actual tool logic
    print(f"Tool called: {tool_name}")
    return {{"result": f"Mock result for {tool_name}"}}
'''
        tool_functions.append(func)

    return '\n'.join(tool_functions)

def convert_agent(agent_name, client_name=None):
    """Convert existing Flask agent to SDK version"""
    agent_dir = Path("agents") / agent_name.lower().replace(" ", "_")

    if not agent_dir.exists():
        print(f"‚ùå Agent not found: {agent_name}")
        print("Run 'list' to see available agents.")
        return

    # Check if already converted
    sdk_file = agent_dir / "agent_sdk.py"
    if sdk_file.exists():
        print(f"‚ö†Ô∏è  SDK version already exists: {sdk_file}")
        print("Delete it first if you want to regenerate.")
        return

    config_file = agent_dir / "config.json"
    if not config_file.exists():
        print(f"‚ùå Config file not found for agent: {agent_name}")
        return

    config = json.loads(config_file.read_text())

    # Add client name to config if provided
    if client_name:
        config['client_name'] = client_name

    # Get template for this agent type
    if config['agent_type'] not in AGENT_TEMPLATES:
        print(f"‚ùå Unknown agent type: {config['agent_type']}")
        return

    template = AGENT_TEMPLATES[config['agent_type']]

    # Format prompt
    prompt = template["prompt_template"].format(**config)

    # Build tools list
    tools = [TOOL_DEFINITIONS[tool] for tool in config["tools"] if tool in TOOL_DEFINITIONS]

    # Generate SDK tool functions
    tool_functions_code = generate_sdk_tool_functions(tools)

    # Generate tool list for SDK
    tool_list = '[' + ', '.join([tool['name'] for tool in tools]) + ']'

    # Generate SDK agent code
    sdk_code = AGENT_SDK_TEMPLATE.format(
        agent_name=config["agent_name"],
        description=template["description"],
        config_json=json.dumps(config, indent=2),
        prompt=prompt,
        tool_functions=tool_functions_code,
        tool_list=tool_list
    )

    # Write SDK version
    sdk_file.write_text(sdk_code)

    # Update requirements.txt
    requirements_file = agent_dir / "requirements.txt"
    current_requirements = requirements_file.read_text()

    # Replace anthropic version with SDK version
    updated_requirements = current_requirements.replace(
        "anthropic==0.39.0",
        "anthropic[agents]==0.39.0"
    )

    if updated_requirements == current_requirements:
        # Didn't find exact version, just add SDK
        updated_requirements = current_requirements.strip() + "\nanthropic[agents]>=0.39.0\n"

    requirements_file.write_text(updated_requirements)

    # Update README
    readme_file = agent_dir / "README.md"
    readme_content = readme_file.read_text()

    sdk_section = f"""

## SDK Version (agent_sdk.py)

This agent now has an SDK version that uses the Anthropic Agent SDK for automatic agentic loops.

### Running SDK Version
```bash
export ANTHROPIC_API_KEY='your_key'
python agent_sdk.py
```

### Benefits of SDK Version
- Automatic agentic loop handling
- Cleaner tool integration
- Better error handling
- Same webhook compatibility

### Switching Between Versions
- Original: `python agent.py`
- SDK: `python agent_sdk.py`

Both versions work with the same webhook endpoint and return compatible JSON.
"""

    readme_file.write_text(readme_content + sdk_section)

    # Mark as SDK-ready in config
    config['sdk_ready'] = True
    if client_name:
        config['client_name'] = client_name
    config_file.write_text(json.dumps(config, indent=2))

    print(f"\n‚úÖ SDK version created: {sdk_file}")
    print(f"\nüìÅ Files updated:")
    print(f"   - agent_sdk.py (new)")
    print(f"   - requirements.txt (updated)")
    print(f"   - README.md (updated)")
    print(f"   - config.json (updated)")

    if client_name:
        print(f"\nüë§ Client: {client_name}")

    print(f"\nüöÄ Next steps:")
    print(f"   1. cd {agent_dir}")
    print(f"   2. Install updated dependencies: pip install -r requirements.txt")
    print(f"   3. Review tool implementations in agent_sdk.py")
    print(f"   4. Test SDK version: python agent_sdk.py")
    print(f"   5. Deploy either version (both work with webhooks)")

    print(f"\nüí° Tip: The SDK version uses Agent class for automatic tool handling.")
    print(f"   Both versions are Gumloop-compatible via webhook!")

def list_agents():
    """List all created agents"""
    agents_path = Path("agents")

    if not agents_path.exists():
        print("No agents directory found. Create your first agent!")
        return

    agents = [d for d in agents_path.iterdir() if d.is_dir()]

    if not agents:
        print("No agents created yet. Run with 'create' command to get started.")
        return

    print(f"\nüìã Found {len(agents)} agent(s):\n")

    for agent_dir in sorted(agents):
        config_file = agent_dir / "config.json"
        sdk_file = agent_dir / "agent_sdk.py"

        if config_file.exists():
            config = json.loads(config_file.read_text())

            # Check if SDK version exists
            has_sdk = sdk_file.exists()
            sdk_indicator = "‚ú® SDK" if has_sdk else ""

            # Check for client name
            client_info = f" | Client: {config.get('client_name', 'N/A')}" if config.get('client_name') else ""

            print(f"  ‚Ä¢ {config['agent_name']} {sdk_indicator}")
            print(f"    Type: {config['agent_type']}")
            print(f"    Tools: {', '.join(config['tools'])}")
            if client_info:
                print(f"    {client_info.strip(' | ')}")
            print(f"    Path: {agent_dir}")
            if has_sdk:
                print(f"    üí° SDK-ready: Use 'python agent_sdk.py' for SDK version")
            print()

def test_agent(agent_name, test_data=None):
    """Test an agent locally"""
    agent_dir = Path("agents") / agent_name.lower().replace(" ", "_")

    if not agent_dir.exists():
        print(f"‚ùå Agent not found: {agent_name}")
        print("Run 'list' to see available agents.")
        return

    config_file = agent_dir / "config.json"
    if not config_file.exists():
        print(f"‚ùå Config file not found for agent: {agent_name}")
        return

    config = json.loads(config_file.read_text())

    # Generate test data based on agent type
    if not test_data:
        test_data = {
            "lead_scorer": {"company": "Acme Corp", "website": "acme.com", "employee_count": 50},
            "content_repurposer": {"content": "AI agents are transforming how businesses operate by automating repetitive tasks and providing intelligent insights."},
            "social_media_manager": {"topic": "Launch of new AI automation tool", "deadline": "2024-01-15"},
            "meeting_scheduler": {"attendees": ["john@example.com", "jane@example.com"], "purpose": "Q1 Planning"},
            "cold_outreach": {"prospect": "John Smith", "company": "Tech Startup Inc", "role": "CTO"},
            "content_researcher": {"topic": "AI trends in marketing automation 2024"},
            "onboarding": {"client_name": "New Client Co", "website": "newclient.com"},
            "proposal_writer": {"discovery_notes": "Client needs help with social media management and content creation"},
            "monitor": {"monitor_condition": "competitor launches new feature", "action": "alert team and compile competitive analysis"},
            "meeting_notes": {"transcript": "Discussed Q1 goals, decided to focus on customer acquisition, John will handle marketing, Sarah will manage sales"}
        }.get(config['agent_type'], {"input": "test"})

    print(f"\nüß™ Testing agent: {config['agent_name']}")
    print(f"Type: {config['agent_type']}")
    print(f"\nTest input:")
    print(json.dumps(test_data, indent=2))
    print(f"\nüí° To run the agent:")
    print(f"   cd {agent_dir}")
    print(f"   export ANTHROPIC_API_KEY='your_key'")
    print(f"   python agent.py")
    print(f"\n   Then in another terminal:")
    print(f"   curl -X POST http://localhost:5000/run \\")
    print(f"     -H 'Content-Type: application/json' \\")
    print(f"     -d '{json.dumps(test_data)}'")

    # Save test data file
    test_file = agent_dir / "test_data.json"
    test_file.write_text(json.dumps(test_data, indent=2))
    print(f"\n   Test data saved to: {test_file}")

def wizard_mode():
    """Interactive wizard for creating agents"""
    print("\nüßô Agent Creation Wizard\n")
    print("Let's create your AI agent step by step.\n")

    # Show available types
    print("Available agent types:")
    for i, (key, template) in enumerate(AGENT_TEMPLATES.items(), 1):
        print(f"  {i}. {key.replace('_', ' ').title()}")
        print(f"     {template['description']}")
        print()

    # Get agent type
    type_choice = input("Select agent type (1-{}): ".format(len(AGENT_TEMPLATES)))
    try:
        type_index = int(type_choice) - 1
        agent_type = list(AGENT_TEMPLATES.keys())[type_index]
    except (ValueError, IndexError):
        print("‚ùå Invalid selection")
        return

    # Get agent details
    agent_name = input("\nAgent name (e.g., 'LeadBot'): ").strip()
    if not agent_name:
        print("‚ùå Agent name is required")
        return

    business_name = input("Business name [Simple Flo Solutions]: ").strip() or "Simple Flo Solutions"
    target_customer = input("Target customer [small service businesses]: ").strip() or "small service businesses"
    brand_voice = input("Brand voice [clear, helpful, professional]: ").strip() or "clear, helpful, professional"

    # Get tools
    template = AGENT_TEMPLATES[agent_type]
    print(f"\nDefault tools: {', '.join(template['default_tools'])}")
    print("Available tools:", ', '.join(TOOL_DEFINITIONS.keys()))
    custom_tools = input("Custom tools (comma-separated, or press Enter for defaults): ").strip()

    trigger_type = input("\nTrigger type (webhook/schedule/email) [webhook]: ").strip() or "webhook"

    # Create mock args object
    class Args:
        pass

    args = Args()
    args.type = agent_type
    args.name = agent_name
    args.business = business_name
    args.target = target_customer
    args.voice = brand_voice
    args.tools = custom_tools if custom_tools else None
    args.trigger = trigger_type

    print("\n" + "="*50)
    print("Creating agent with:")
    print(f"  Name: {agent_name}")
    print(f"  Type: {agent_type}")
    print(f"  Business: {business_name}")
    print(f"  Target: {target_customer}")
    print("="*50 + "\n")

    create_agent(args)

def deploy_help(agent_name=None):
    """Show deployment instructions"""
    print("\nüöÄ Deployment Guide\n")

    if agent_name:
        agent_dir = Path("agents") / agent_name.lower().replace(" ", "_")
        if not agent_dir.exists():
            print(f"‚ùå Agent not found: {agent_name}")
            return
        print(f"Deploying: {agent_name}\n")
    else:
        print("General deployment instructions:\n")

    print("### Option 1: Railway (Recommended)")
    print("1. Install Railway CLI:")
    print("   npm i -g @railway/cli")
    print()
    print("2. Login:")
    print("   railway login")
    print()
    print("3. Initialize and deploy:")
    if agent_name:
        print(f"   cd {agent_dir}")
    print("   railway init")
    print("   railway up")
    print()
    print("4. Add environment variables:")
    print("   railway variables set ANTHROPIC_API_KEY=your_key")
    print()

    print("\n### Option 2: Render")
    print("1. Create account at render.com")
    print("2. Connect your GitHub repo")
    print("3. Create new Web Service")
    print("4. Select your agent directory")
    print("5. Add ANTHROPIC_API_KEY environment variable")
    print()

    print("\n### Option 3: Heroku")
    print("1. Install Heroku CLI")
    print("2. Login: heroku login")
    if agent_name:
        print(f"3. cd {agent_dir}")
    print("3. heroku create your-agent-name")
    print("4. git push heroku main")
    print("5. heroku config:set ANTHROPIC_API_KEY=your_key")
    print()

def main():
    parser = argparse.ArgumentParser(
        description="AI Agent CLI - Generate and manage AI agents",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Interactive wizard
  ./agent-cli.py wizard

  # Create agent with parameters
  ./agent-cli.py create --type lead_scorer --name "LeadBot" --business "Vibe Marketing"

  # List all agents (shows SDK status)
  ./agent-cli.py list

  # Convert agent to SDK version
  ./agent-cli.py convert --name "LeadBot" --client "Acme Corp"

  # Test an agent
  ./agent-cli.py test --name "LeadBot"

  # Deployment help
  ./agent-cli.py deploy --name "LeadBot"
        """
    )

    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    # Create command
    create_parser = subparsers.add_parser('create', help='Create a new agent')
    create_parser.add_argument("--type", required=True,
                       choices=list(AGENT_TEMPLATES.keys()),
                       help="Agent type")
    create_parser.add_argument("--name", required=True, help="Agent name")
    create_parser.add_argument("--business", help="Business name")
    create_parser.add_argument("--target", help="Target customer description")
    create_parser.add_argument("--trigger", choices=["webhook", "schedule", "email"],
                       help="Trigger type")
    create_parser.add_argument("--tools", help="Comma-separated tool list")
    create_parser.add_argument("--voice", help="Brand voice description")

    # List command
    list_parser = subparsers.add_parser('list', help='List all agents')

    # Test command
    test_parser = subparsers.add_parser('test', help='Test an agent')
    test_parser.add_argument("--name", required=True, help="Agent name to test")

    # Wizard command
    wizard_parser = subparsers.add_parser('wizard', help='Interactive agent creation wizard')

    # Deploy command
    deploy_parser = subparsers.add_parser('deploy', help='Show deployment instructions')
    deploy_parser.add_argument("--name", help="Agent name to deploy")

    # Convert command
    convert_parser = subparsers.add_parser('convert', help='Convert agent to use Anthropic Agent SDK')
    convert_parser.add_argument("--name", required=True, help="Agent name to convert")
    convert_parser.add_argument("--client", help="Client name (optional, for tracking)")

    args = parser.parse_args()

    # Handle commands
    if args.command == 'create':
        create_agent(args)
    elif args.command == 'list':
        list_agents()
    elif args.command == 'test':
        test_agent(args.name)
    elif args.command == 'wizard':
        wizard_mode()
    elif args.command == 'deploy':
        deploy_help(args.name if hasattr(args, 'name') else None)
    elif args.command == 'convert':
        convert_agent(args.name, args.client if hasattr(args, 'client') else None)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
